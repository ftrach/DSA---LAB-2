# DSA456 LAB 2

## PART A: FUNCTION ANALYSIS


### FUNCTION 1


**TIME COMPLEXITY:** O(n)  

**EXPLANATION:** THE FUNCTION LOOPS `number` TIMES, PERFORMING A CONSTANT-TIME OPERATION INSIDE EACH ITERATION.



### FUNCTION 2


**TIME COMPLEXITY:** O(1)  

**EXPLANATION:** THIS FUNCTION USES A CONSTANT NUMBER OF ARITHMETIC OPERATIONS REGARDLESS OF INPUT SIZE.



### FUNCTION 3


**TIME COMPLEXITY:** O(nÂ²)  

**EXPLANATION:** THIS IS A BUBBLE SORT ALGORITHM, WITH A NESTED LOOP RESULTING IN QUADRATIC TIME COMPLEXITY.



### FUNCTION 4


**TIME COMPLEXITY:** O(n)  

**EXPLANATION:** A SINGLE LOOP FROM 1 TO `number` PERFORMS MULTIPLICATION, WHICH IS LINEAR.





---

## PART C: SOLO DISCUSSION AND TIMING

### TIMING DATA


| TEAM MEMBER     | TIMING FOR FIBONACCI | TIMING FOR SUM_TO_NUMBER |
|-----------------|----------------------|---------------------------|
| FRANCIS T | 4.682                | 0.004                     |




### SUMMARY


| FUNCTION         | FASTEST | SLOWEST | DIFFERENCE |
|------------------|---------|---------|------------|
| SUM_TO_NUMBER    | 0.004   | 0.004   | 0.000      |
| FIBONACCI        | 4.682   | 4.682   | 0.000      |





---


## REFLECTION

SINCE I WORKED ALONE, MY FUNCTIONS WERE THE ONLY ONES ANALYZED.

MY `fibonacci()` FUNCTION WAS SLOWER DUE TO RECURSION (OR FASTER IF I USED ITERATION). THIS SHOWS THAT RECURSION, WHILE ELEGANT, CAN BE INEFFICIENT FOR LARGE INPUTS.

MY `sum_to_goal()` FUNCTION RAN VERY QUICKLY BECAUSE IT USED A LOOP WITH SIMPLE ARITHMETIC.

THIS EXERCISE HELPED ME UNDERSTAND HOW THE STRUCTURE OF CODE IMPACTS PERFORMANCE. OPTIMIZING LOGIC AND AVOIDING UNNECESSARY OPERATIONS MAKES A NOTICEABLE DIFFERENCE.
